package riscv.plugins.cheriEncrypt
import spinal.core._
import spinal.lib._
import spinal.lib.fsm._

/** This is a direct-mapped cache implementation with write-back */
/** The cache is constructed from synchronous read and write */
/** For small data cache sizes LUT RAM is inferred during FPGA synthesis, e.g cache line size of 256
  */
/** For large data cache sizes Block RAM is inferred */
/** when block Ram is inferred, the 4 bit mask for byte writes infers 4 block RAMs even if it should
  * fit into 1.
  */
/** write back is used during data write operations. Write operations update the cache only. A dirty
  * bit for each cache line is set when there is a write operation to a cache line. The cache line
  * needs to be written back to memory when a new cache line is loaded and at the end before exiting
  * the invoked code.
  */

/** 32 bit input address \| tagBits | lineBits | wordBits | byteBits |
  *
  * plus a byte mask for writes
  */

/** The Data Cache - this is addressed by wordBits and lineBits */
/** The Tag Cache - this is addressed by lineBits and then the tag is compared for a hit */
/** The Dirty Cache - this is addressed by lineBits */

/** A read or a write both take 1 clock cycle */

/** define generics */
case class cacheConfig(
    addrWidth: BitCount,
    dataWidth: BitCount,
    maskWidth: BitCount, // byte mask - mask for writing bytes at a time for byte store or half word store
    sizeCacheLine: Int, // size of cache line In bytes
    numCacheLines: Int, // number of cache lines
    // bitsPerByte: Int = 8,
    bitsPerWord: Int = 32
)
/** can't include these in list above because dependent on above parameters, so have to define them
  * as methods, can then index them as generics the same as above
  */
{

  /** fixed value */
  def bitsPerByte: Int = 8

  /** number of bits to address bytes in a word - lower two bits of the address index the bytes */
  def byteBits: Int = log2Up(maskWidth.value)

  /** number of words per cache line */
  def numWords: Int = sizeCacheLine * bitsPerByte / bitsPerWord

  /** number of bits needed to address all the words in a cache line */
  def wordBits: Int = log2Up(numWords)

  /** number of bits needed to address all the cache lines */
  def lineBits: Int = log2Up(numCacheLines)

  /** number of tag bits */
  def tagBits: Int = addrWidth.value - byteBits - wordBits - lineBits

  /** data cache size in words */
  def cacheSize: Int = numWords * numCacheLines

  /** number of dirty bits to indicate when data has been written to the cache from the processor -
    * used for write back - 1 dirty bit per cache line since it must be read and written in a cache
    * line block
    */
  def dirtyBits: Int = 1

}

/** define input / output signals */
/** define separate memwrite and procwrite here because when writing to the cache from memory we
  * need to write the data and the tag, but not the dirty bit, and when writing from the processor
  * to the cache we need to write the data and the dirty bit, but not the tag. memwrite and
  * procwrite are both low to read data.
  */
case class CacheCmd(cacheConfig: cacheConfig) extends Bundle {
  val address = Bits(cacheConfig.addrWidth)
  val wdata = Bits(cacheConfig.dataWidth)
  val wmask = Bits(
    cacheConfig.maskWidth
  ) // Todo - this can be labelled as mask not wmask because used in read and write
  val memwrite = Bool() // write to cache from memory - when writing a cache line into the cache
  val procwrite = Bool() // write to cache from processor - when processor writing data
  // specifies where the input is from: either from processor-stage (False)  or from memory-via AES encryption (True)
  val inputFromMem = Bool()
}

/** and then define the outputs in a bundle */
case class CacheRsp(cacheConfig: cacheConfig) extends Bundle {

  val rdata = Bits(cacheConfig.dataWidth) // data read value
  val rtag = Bits(cacheConfig.tagBits bits) // tag read value //ToDo don't currently use this output
  val hit = Bool() // tag hit - data present in cache
  val rdirty = Bool() // indicates cache line has been written by processor - write-back needed
  val procread =
    Bool() // indicates data output generated by a processor read (from stage), otherwise write
  val memread =
    Bool() // indicates data output generated by a memory read (via AES core), otherwise write
  // specifies where the output is for: either processor-stage (False) or to memory-via AES encryption (True)
  val outputForMem = Bool()

  /** Held registered outputs used for feedback / processing */
  // address of new cache line to read from memory if cache miss
  val readLineAddr = Bits(cacheConfig.addrWidth)
  // address of writeback cache line if need to do a writeback
  val writebackLineAddr = Bits(cacheConfig.addrWidth)
  // current full address of read/write word in cache line if need to do a repeat read/write after a miss (and writeback and read cache line)
  val currentAddr = Bits(cacheConfig.addrWidth)
  // current mask if need to a repeat read/write
  val currentWmask = Bits(cacheConfig.maskWidth)
  // current wdata if need to a repeat read/write
  val curentWdata = Bits(cacheConfig.dataWidth)
  // current procwrite if need to a repeat read/write
  val currentMemwrite = Bool()
  // current procwrite if need to a repeat read/write
  val currentProcwrite = Bool()
  // current input selection if need to do a repeat read/write
  val currentInputFromMem = Bool()

  // Todo - change output
  // used to set dirty bit in dirty ram
  val rProcWriteHit = Bool()
}

/** then use master/slave handshake so can include both in/out signals in one bundle */
case class cacheIo(cacheConfig: cacheConfig) extends Bundle with IMasterSlave {

  val cmd = Flow(CacheCmd(cacheConfig)) // stream not req. cache mem always ready to accept
  val rsp = Flow(CacheRsp(cacheConfig))

  /** Set the direction of each bundle/signal from a master point of view */
  override def asMaster(): Unit = {

    /** declare outputs for master, so will be inputs for slave */
    master(cmd)

    /** declare inputs for master, so will be outputs for slave */
    slave(rsp)
  }
}

class cache(cacheConfig: cacheConfig) extends Component {

  assert(
    cacheConfig.addrWidth != (cacheConfig.wordBits + cacheConfig.lineBits),
    "address width needs to be the address width for cache"
  )

  /** Inputs / Outputs */
  val io = slave(cacheIo(cacheConfig))

  /** ------------------------------------------- */
  /** create tag cache RAM dataWidth x numData */
  val tagRAM = Mem(Bits(cacheConfig.tagBits bits), cacheConfig.numCacheLines)

  /** tag cache RAM address - this is the line bits only */
  val tagRAMaddr = Bits(cacheConfig.lineBits bits)
  tagRAMaddr := io.cmd.payload.address(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto (cacheConfig.byteBits + cacheConfig.wordBits)
  )

  /** tag write value */
  val wtag = Bits(cacheConfig.tagBits bits)
  wtag := io.cmd.payload.address(
    (cacheConfig.addrWidth.value - 1) downto (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits)
  )

  /** tag Read value - async read intermediate value */
  val rtag_int = Bits(cacheConfig.tagBits bits)

  /** lets do synchronous write for memory write, but asynchronous read so get hit output before do
    * a processor write to data cache because if it is a miss we need to get a new cache line before
    * we do the write
    */
  /** asynchronous read is Ok for LUT RAM which should be small anyway if we only have a small
    * number of cache lines
    */

  /** Tag Cache - Infer a write port. data is written synchronously when valid && memory write only.
    */
  tagRAM.write(
    address = tagRAMaddr.asUInt,
    data = wtag,
    enable = io.cmd.valid && io.cmd.payload.memwrite
  )

  /** Tag Cache - Infer a read port. data is read asynchronously on same clock cycle */
  rtag_int := tagRAM.readAsync(
    address = tagRAMaddr.asUInt
  )

  /** tag hit or miss signal */
  /** compare tag read out of tag cache to tag part of input address */
  val tagHit_int = Bool()
  tagHit_int := rtag_int === wtag

  val procwrite_hit = Bool() // write data cache from processor only if tag hit
  procwrite_hit := tagHit_int & io.cmd.payload.procwrite

  /** assign output */
  /** Delay by 1 clk cycle since tag cache is an asynchronous read */

  io.rsp.payload.hit := RegNext(tagHit_int)

  /** tag Read value - sync reg read value */
  io.rsp.payload.rtag := RegNext(rtag_int)

  /** ------------------------------------------- */
  /** create data cache RAM dataWidth x numData */
  val dataRAM = Mem(Bits(cacheConfig.dataWidth), cacheConfig.cacheSize)

  /** data cache RAM address - this is wordsBits + lineBits */
  val dataRAMaddr = Bits((cacheConfig.wordBits + cacheConfig.lineBits) bits)
  dataRAMaddr := io.cmd.payload.address(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto (cacheConfig.byteBits)
  )

  /** Data Cache - Infer a read/write port. data is written when enable && write. Return the read
    * data, the read occurs when enable is true
    */
  io.rsp.payload.rdata := dataRAM.readWriteSync(
    address = dataRAMaddr.asUInt,
    data = io.cmd.payload.wdata,
    enable = io.cmd.valid,
    /** update data cache for a memory write or a processor write if there was a hit */
    write = io.cmd.payload.memwrite | procwrite_hit,
    mask = io.cmd.payload.wmask
  )

  /** processor read indicator output */
  io.rsp.payload.procread := RegNext(!(io.cmd.payload.procwrite) && !(io.cmd.payload.inputFromMem))

  /** memory read indicator output */
  io.rsp.payload.memread := RegNext((io.cmd.payload.inputFromMem) && !(io.cmd.payload.memwrite))

  /** inputFromMem -> outputForMem indicator output */
  io.rsp.payload.outputForMem := RegNext(io.cmd.payload.inputFromMem)

  /** data valid output */
  /** synchronous read has a 1 cycle latency so need reg */
  io.rsp.valid := RegNext(io.cmd.valid)

  /** ------------------------------------------- */
  /** create dirty bit cache RAM dataWidth x numData */
  // ToDo- redo this as a generic set of registers because you have to do a read the
  // first time the dirty bit is set to find out if set or not, which is a pain
  // However the current design is easy to create a generic size
  // Todo - do generic size with registers and then it will output dirty straight away
  // current design has additional procwrite_hit Reg output which goes high when ANY cacheline needs a
  // writeback so the controller knows it needs to do a read check for the dirty bit for a given cacheline.
  // the controller can put it in a held register and reset it at the end of a writeback.
  io.rsp.payload.rProcWriteHit := RegNext(procwrite_hit)

  val dirtyRAM = Mem(Bits(cacheConfig.dirtyBits bits), cacheConfig.numCacheLines)

  /** dirty cache RAM address - this is the line bits only */
  val dirtyRAMaddr = Bits(cacheConfig.lineBits bits)
  dirtyRAMaddr := tagRAMaddr

  /** dirty write value */
  val wdirty = Bits(cacheConfig.dirtyBits bits)

  /** when write from processor set the bit, when write from memory reset the bit (because we load
    * new data and should have done write-back if required)
    */
  wdirty := (io.cmd.payload.procwrite | (!io.cmd.payload.memwrite)).asBits

  /** dirty Read value */
  val rdirty = Bits(cacheConfig.dirtyBits bits)

  /** dirty Cache - Infer a read/write port. data is written when enable && write. Return the read
    * data, the read occurs when enable is true
    */
  rdirty := dirtyRAM.readWriteSync(
    address = dirtyRAMaddr.asUInt,
    data = wdirty,
    enable = io.cmd.valid,
    /** update dirty cache for a memory write or a processor write only if there was a hit */
    write = io.cmd.payload.memwrite | procwrite_hit
  )

  /** assign output */
  io.rsp.payload.rdirty := rdirty.asBool

  /** held registers */
  val bytemaskReg = Reg(Bits(cacheConfig.maskWidth))
  val wordBitsReg = Reg(Bits(cacheConfig.wordBits bits))
  val linebitsReg = Reg(Bits(cacheConfig.lineBits bits))
  val tagbitsReg = Reg(Bits(cacheConfig.tagBits bits))
  val rTagReg = Reg(Bits(cacheConfig.tagBits bits))
  val wdataReg = Reg(Bits(cacheConfig.dataWidth))
  val memwriteReg = Reg(Bool()) init (False)
  val procWriteReg = Reg(Bool()) init (False)
  val inputFromMemReg = Reg(Bool()) init (False)
  val writebackLineAddrReg = Reg(Bits(cacheConfig.addrWidth)) // need for proc and mem

  /** hold registers when there is a processor read/write or mem read/write */
  /** We need this writebackLineAddr output for both processor and the memory side */
  /** assign the cache line address output for when a write back is needed. This is the address
    * already in the cache. This is the start address to write. It needs padding with zeros to make
    * up 32bits for the cache line start - needs to be cache line aligned
    */
  when(io.cmd.valid) {

    /** get tag part */
    writebackLineAddrReg(
      (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits + cacheConfig.tagBits - 1) downto (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits)
    ) := rtag_int // rtag
    /** get line part */
    writebackLineAddrReg(
      (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto (cacheConfig.byteBits + cacheConfig.wordBits)
    ) := io.cmd.payload.address(
      (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits))
    )
  }

  /** pad rest with zeros */
  writebackLineAddrReg(
    (cacheConfig.byteBits + cacheConfig.wordBits) - 1 downto 0
  ) := 0x0
  io.rsp.payload.writebackLineAddr := writebackLineAddrReg

  /** hold registers only when there is a processor read/write */
  when(io.cmd.valid & !io.cmd.payload.inputFromMem) {
    bytemaskReg := io.cmd.payload.wmask
    wordBitsReg := io.cmd.payload.address(
      (cacheConfig.byteBits + cacheConfig.wordBits - 1) downto ((cacheConfig.byteBits))
    )
    linebitsReg := io.cmd.payload.address(
      (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits))
    )
    tagbitsReg := io.cmd.payload.address(
      (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits + cacheConfig.tagBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits
        + cacheConfig.lineBits))
    )
    wdataReg := io.cmd.payload.wdata
    memwriteReg := io.cmd.payload.memwrite
    procWriteReg := io.cmd.payload.procwrite
    inputFromMemReg := io.cmd.payload.inputFromMem
    rTagReg := rtag_int
  }

  /** assign current address output to do a repeat read/write following a miss */
  io.rsp.payload.currentAddr((cacheConfig.byteBits - 1) downto ((0))) := 0x0
  io.rsp.payload.currentAddr(
    (cacheConfig.byteBits + cacheConfig.wordBits - 1) downto ((cacheConfig.byteBits))
  ) := wordBitsReg
  io.rsp.payload.currentAddr(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits))
  ) := linebitsReg
  io.rsp.payload.currentAddr(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits + cacheConfig.tagBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits
      + cacheConfig.lineBits))
  ) := tagbitsReg

  /** assign the cache line address output for when there is a miss. This is the asking address,
    * delayed by 1clk to align with output data. This is the start address to fetch. It needs
    * padding with zeros to make up 32bits for the cache line start - needs to be cache line aligned
    */
  io.rsp.payload.readLineAddr(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits))
  ) := linebitsReg
  io.rsp.payload.readLineAddr(
    (cacheConfig.byteBits + cacheConfig.wordBits + cacheConfig.lineBits + cacheConfig.tagBits - 1) downto ((cacheConfig.byteBits + cacheConfig.wordBits
      + cacheConfig.lineBits))
  ) := tagbitsReg
  io.rsp.payload.readLineAddr((cacheConfig.byteBits + cacheConfig.wordBits) - 1 downto 0) := 0x0

  /** assign other held register outputs to do a repeat read/write following a miss */
  io.rsp.payload.curentWdata := wdataReg
  io.rsp.payload.currentMemwrite := memwriteReg
  io.rsp.payload.currentProcwrite := procWriteReg
  io.rsp.payload.currentWmask := bytemaskReg
  io.rsp.payload.currentInputFromMem := inputFromMemReg
}

//Generate the MyTopLevel's VHDL
object cacheVhdl {
  def main(args: Array[String]) {
    val cacheConfig = new cacheConfig(
      addrWidth = 32 bits, // 8
      dataWidth = 32 bits,
      sizeCacheLine = 16, // In bytes 256
      numCacheLines = 4,
      maskWidth = 4 bits
    )
    SpinalVhdl(new cache(cacheConfig))
  }
}
